#include "all.h"

struct halostruct {
  float pos[3];
  float vel[3];
  long long nextid=-1;
};
struct halostruct *haloA, *haloB;
long long *headofchainA, *headofchainB;

void read_singlesnap(unsigned int snapnum)
{
  int len;
  unsigned int iFile, i,j,k,pid,totalids;
  MyIDtype currentHalo, nHalos,iHalo,hosthalo;
  char filename[MAXSTRING];
  char buffer[MAXSTRING];
  char dummystr[MAXSTRING];
  FILE *fp,*fr;
  //struct Gadget_particle *P;
  //unsigned int *Id;
  //int *PIDmap;
  int lowresflag;
  MyIDtype maxaquariusid;
  float record;
  TotNhalos = 0;
  currentHalo = 0;
  for(iFile=snapnum;iFile<=snapnum;iFile++)
    {
      //printf("iFile = %d\n",iFile);
      strncpy(filename,"",sizeof(filename));
      (void) getFilename(filename,iFile);
      //printf("%s\n",strcat(filename,".AHF_particles"));
      fp = fopen(strcat(filename,".AHF_particles"), "r");
      fscanf(fp,"%llu",&(SnapNhalos[iFile]));
      fclose(fp);
      TotNhalos += SnapNhalos[iFile];
      //printf("%d snap = %llu halos\n",iFile,SnapNhalos[iFile]);
    }
  if(TotNhalos <= MAXUSEABLE)
    {
      IDmap = calloc(TotNhalos,sizeof(MyIDtype));
      HaloTable = calloc(TotNhalos,sizeof(struct HALOPROPS));
      TotNavatars = TotNhalos;
      TotNhalosUsed = TotNhalos;
      Avatar= calloc(TotNhalos,sizeof(MyIDtype));
    }
  else
    {
      fprintf(stderr,"Error: Total halo exceed the maximum:%llu\nExiting...\n",MAXUSEABLE);
      exit(0);
    }
  for(iFile=snapnum;iFile<=snapnum;iFile++)
    {
      strncpy(filename,"",sizeof(filename));
      (void) getFilename(filename,iFile);
      fp = fopen(strcat(filename,".AHF_halos"), "r");
      fgets(buffer,MAXSTRING,fp);
      for(iHalo=0;iHalo<SnapNhalos[iFile];iHalo++)
	{
	  //printf("iHalo = %llu\n",iHalo);
	  fscanf(fp,"%llu %llu %llu %g %llu %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g %g",
		 &(HaloTable[currentHalo].ID),
		 &(HaloTable[currentHalo].hostHalo),
		 &(HaloTable[currentHalo].numSubStruct),
		 &(HaloTable[currentHalo].Mvir),
		 &(HaloTable[currentHalo].npart),
		 &(HaloTable[currentHalo].Xc),
		 &(HaloTable[currentHalo].Yc),
		 &(HaloTable[currentHalo].Zc),
		 &(HaloTable[currentHalo].VXc),
		 &(HaloTable[currentHalo].VYc),
		 &(HaloTable[currentHalo].VZc),
		 &(HaloTable[currentHalo].Rvir), 
		 &(HaloTable[currentHalo].Rmax),
		 &(HaloTable[currentHalo].r2),
		 &(HaloTable[currentHalo].mbp_offset),
		 &(HaloTable[currentHalo].com_offset),
		 &(HaloTable[currentHalo].Vmax),
		 &(HaloTable[currentHalo].v_esc),
		 &(HaloTable[currentHalo].sigV),
		 &(HaloTable[currentHalo].lambda),
		 &(HaloTable[currentHalo].lambdaE),
		 &(HaloTable[currentHalo].Lx),
		 &(HaloTable[currentHalo].Ly),
		 &(HaloTable[currentHalo].Lz),
		 &(HaloTable[currentHalo].b),
		 &(HaloTable[currentHalo].c),
		 &(HaloTable[currentHalo].Eax),
		 &(HaloTable[currentHalo].Eay),
		 &(HaloTable[currentHalo].Eaz),
		 &(HaloTable[currentHalo].Ebx), 
		 &(HaloTable[currentHalo].Eby),
		 &(HaloTable[currentHalo].Ebz),
		 &(HaloTable[currentHalo].Ecx), 
		 &(HaloTable[currentHalo].Ecy), 
		 &(HaloTable[currentHalo].Ecz),
		 &(HaloTable[currentHalo].ovdens),
		 &(HaloTable[currentHalo].nbins),
		 &(HaloTable[currentHalo].fMhires),
		 &(HaloTable[currentHalo].Ekin),
		 &(HaloTable[currentHalo].Epot),
		 &(HaloTable[currentHalo].SurfP),
		 &(HaloTable[currentHalo].Phi0),
		 &(HaloTable[currentHalo].cNFW) 
		 );
	  IDmap[currentHalo] = HaloTable[currentHalo].ID;
	  HaloTable[currentHalo].AHFID = HaloTable[currentHalo].ID; 
	  HaloTable[currentHalo].SnapID = iFile;
	  HaloTable[currentHalo].nAvatars = 1;
	  HaloTable[currentHalo].AvatarList = calloc(HaloTable[currentHalo].nAvatars,sizeof(MyIDtype));
	  HaloTable[currentHalo].AvatarList[0] = currentHalo;
	  Avatar[currentHalo] = currentHalo;
	  HaloTable[currentHalo].ProgAvatarFlag = 0;
	  HaloTable[currentHalo].TroubleFlag = 0;
	 
	  //printf("%llu : %llu\n", currentHalo,IDmap[currentHalo]);
	  currentHalo++;
	}
      fclose(fp);
      
    }

  if(TotNhalos != (currentHalo))
    {
      fprintf(stderr,"Error: Problem in halo catalogues: %llu,%llu\nExiting...\n",TotNhalos,currentHalo);
      exit(0);
    }
  SubTree = calloc(TotNhalos,sizeof(MyIDtype));
  for(iHalo=0;iHalo<TotNhalos;iHalo++)
    {
      SubTree[iHalo] = IDsearch(HaloTable[iHalo].hostHalo);
      //printf("halo %llu:%llu hosted in %llu: %llu\n", iHalo,IDmap[iHalo], SubTree[iHalo],HaloTable[iHalo].hostHalo);
    }
  
  for(iHalo=0;iHalo<TotNhalos;iHalo++)
    {
      hosthalo = SubTree[iHalo];
      if(hosthalo < NULLPOINT)
	{
	  if(HaloTable[hosthalo].Mvir < 1.e-30)
	    HaloTable[iHalo].Mvir = 0.;
	}
    }


  read_particles(snapnum);
  sprintf(filename,"%s/snapdir_%03d/%s%03d",gadgetfolder,(int)snapnum,gadgetPrefix,(int)snapnum);
  totalids =  (unsigned int) gadget_load_snapshot(filename,16);
  /* for (i=1;i<=totalids;i++) */
  /*   { */
  /*     printf("%d => %d\n",(int)i,(int)(PIDmap[i])); */
  /*   } */
  //printf("Total particle : %llu\n",i);
  //maxaquariusid = 18535972;
  fr = fopen("nearestremove.txt","w+"); 
  
  for(iHalo=0;iHalo < TotNhalos;iHalo++)
    {
      lowresflag = 0;
      for(j=0;j<HaloTable[iHalo].npart;j++)
	{
	  pid = HaloTable[iHalo].Particles[j].ParticleID;
	  //printf("pid = %d\n",pid);
	  pid= (unsigned int)PIDmap[(int)pid];
	  HaloTable[iHalo].Particles[j].X = (float) P[pid].Pos[0];
	  HaloTable[iHalo].Particles[j].Y = (float) P[pid].Pos[1];
	  HaloTable[iHalo].Particles[j].Z = (float) P[pid].Pos[2];
	  HaloTable[iHalo].Particles[j].Vx = (float) P[pid].Vel[0];
	  HaloTable[iHalo].Particles[j].Vy = (float) P[pid].Vel[1];
	  HaloTable[iHalo].Particles[j].Vz = (float) P[pid].Vel[2];

  
	  //printf("converted pid = %d\n",pid);
	  if(P[pid].Type != 1)
	    {
	      printf("Halo: %llu => %llu\n",iHalo,HaloTable[iHalo].Particles[j].ParticleID);
	      lowresflag += 1;
	    }
	}

      
      if(lowresflag > 0 || HaloTable[SubTree[iHalo]].ID == NULLPOINT)
	{
	  fprintf(fr,"%llu\t%f\t%d\t%llu\n",iHalo,sqrt( pow(HaloTable[iHalo].Xc - HaloTable[0].Xc,2) + pow(HaloTable[iHalo].Yc - HaloTable[0].Yc,2) + pow(HaloTable[iHalo].Zc-HaloTable[iHalo].Zc,2)), lowresflag, HaloTable[iHalo].npart );
	  HaloTable[iHalo].ID = NULLPOINT;
	}
    }
  fclose(fr);
  printf("Tothalos before: %llu\n", TotNhalos);
  record = (float) TotNhalos;
  /* fr = fopen("before.txt","w+"); */
  /* for(iHalo=0;iHalo < TotNhalos;iHalo++) */
  /*   { */
  /*     fprintf(fr,"%f %f %f\n",HaloTable[iHalo].Xc,HaloTable[iHalo].Yc,HaloTable[iHalo].Zc); */
  /*   } */
  /* fclose(fr); */
  resetIDmap();
  printf("Tothalos after: %llu\n", TotNhalos);
  /* printf("ration: %f\n",record/(float) TotNhalos); */
  
  /* fr = fopen("record.txt","a+"); */
  /* fprintf(fr,"%d\t%f\t%d\n",snapnum, (float)TotNhalos/record,(int)record); */
  /* fclose(fr); */

  /* fr = fopen("after.txt","w+"); */
  /* for(iHalo=0;iHalo < TotNhalos;iHalo++) */
  /*   { */
  /*     fprintf(fr,"%f %f %f\n",HaloTable[iHalo].Xc,HaloTable[iHalo].Yc,HaloTable[iHalo].Zc); */
  /*   } */
  /* fclose(fr); */
  strncpy(filename,"",sizeof(filename));
  (void) getFilteredFilename(filename,snapnum);
  printoutfullAHF(filename);
}

void readMFOF()
{
}
int main(void)
{
  long long i;
  long long max_halo = 10000000;
  long long nhalosA = 0, nhalosB = 0;
  // read haloA : AHF
  
}